
[1. 객체와 클래스에 대한 설명으로 틀린 것은? (3)]
	1. 클래스는 객체를 생성하기 위한 설계도와 같은 것이다.
	2. new 연산자로 클래스의 생성자를 호출함으로써 객체가 생성된다.
		- (클래스 이름)(변수 이름) = (new)(클래스 이름)();
		- 생성자 안에 매개변수에 따라 오버로딩이 가능하다.
	*3. 하나의 클래스로 하나의 객체만 생성할 수 있다.
		- x, 여러 객체를 생성할 수 있다.
	4. 객체는 클래스의 인스턴스이다.

[2. 클래스의 구성 맴버가 아닌 것은? (4)]
	1. 필드
	2. 생성자
	3. 메소드
	*4. 로컬 변수
		- 로컬 변수(지역 변수)는 함수 안에서 선언된 변수이다.
		- 함수 밖으로 벗어나면 사용할 수 없다.
		
[3. 필드, 생성자, 메소드에 대한 설명으로 틀린 것은? (4)]
	1. 필드는 객체의 데이터를 저장한다.
	2. 생성자는 객체의 초기화를 담당한다.
	3. 메소드는 겍체의 동작 부분으로, 실행 코드를 가지고 있는 블록이다.
	*4. 클래스는 반드시 필드와 메소드를 가져야 한다.	
		- 생략 가능하다. 필드만 있어도 되고, 메소드만 있어도 된다.(main()메소드)
		
[4. 필드에 대한 설명으로 틀린 것은? (3)]
	1. 필드는 메소드에서 사용할 수 있다.
		- this.로 사용 가능하다.(생략해도 된다.)
	2. 인스턴스 필드 초기화는 생성자에서 할 수 있다.
		- 생성자에서 필드 초기화 한 후, 메소드로 값을 넣어줄 수 있다.(게터세터)
	*3. 필드는 반드시 생성자 선언 전에 선언되어야 한다.
		- 클래스 블록 어디든지 존재할 수 있다.
	4. 필드는 초기값을 주지 않더라도 기본값으로 자동 초기화된다.
		- ㅇㅇ

[5. 생성자에 대한 설명으로 틀린 것은? (1)]
	*1. 객체를 생성하려면 생성자 호출이 반드시 필요한 것은 아니다.
		- new로 호출 해야 한다.
	2. 생성자는 다른 생성자를 호출하기 위해 this()를 사용할 수 있다.
	3. 생성자가 선언되지 않으면 컴파일러가 기본 생성자를 추가한다.
		- 클래스(){}
	4. 외부에서 객체를 생성할 수 없도록 생성자에 private 접근 제한자를 붙일 수 있다.
		- 생성할 수 있도록 생성자에 public 접근 제한자를 붙일 수 있다.
		
[6. 메소드에 대한 설명으로 틀린 것은? (4)]
	1. 리턴값이 없는 메소드는 리턴 타입을 void로 해야 한다.
	2. 리턴 타입이 있는 메소드는 리턴값을 지정하기 위해 반드시 return문이 있어야 한다.
		- 리턴 타입을 리턴값의 데이터 타입으로 지정해야 한다.
	3. 매개값의 수를 모를 경우 ... 를 이용해서 매개변수를 선언할 수 있다.
		- 가변 길이 배열 선언과 비슷하다.
	4. 메소드 이름은 중복해서 선언할 수 없다.
		- 메소드 오버로딩으로 이름 중복 사용 가능하다.
		
[7. 메소드 오버로딩에 대한 설명으로 틀린 것은? (2)]
	1. 동일한 이름의 메소드를 여러 개 선언하는 것을 말한다.
	2. 반드시 리턴 타입이 달라야 한다.
		- 매개변수가 달라도 된다.
	3. 매개변수의 타입, 수, 순서를 다르게 선언해야 한다.
	4. 매개값의 타입 및 수에 따라 호출된 메소드가 선택된다.
	
[8. 인스턴스 맴버와 정적 맴버에 대한 설명으로 틀린 것은? (2)]
	1. 정적 맴버는 static으로 선언된 필드와 메소드를 말한다.
	2. 인스턴스 필드는 생성자 및 정적 블록에서 초기화될 수 있다.
		- 정적 블록에서 초기화될 수 없다.
	3. 정적 필드와 정적 메소드는 객체 생성 없이 클래스를 통해 접근할 수 있다.
		- 클래스.로 접근할 수 있다.
	4. 인스턴스 필드와 메소드는 객체를 생성하고 사용해야 한다.
		- new로 객체를 생성한 후 호출한다.
		
[9. final 필드와 상수(static final) 에 대한 설명으로 틀린 것은? (2)]
	1. final 필드와 상수는 초기값이 저장되면 값을 변경할 수 없다.
		- final은 값이 고정되어서 수정 불가능하다.
	2. final 필드와 상수는 생성자에서 초기화될 수 있다.
		- final은 할 수 있는데, 상수는 생성과 동시에 초기화되어야 한다.
	3. 상수의 이름은 대문자로 작성하는 것이 관례이다.
	4. 상수는 객체 생성 없이 클래스를 통해 사용할 수 있다.
		- static이기 때문이다.
		
	- 변수를 final로 지정하면 그 값은 바꾸지 못한다.
	- 메소드를 final로 지정하면 오버라이드 할 수 없다.
	- 클래스를 final로 지정하면 확장할 수 없다.(하위 클래스 생성 불가)
		

[10. 패키지에 대한 설명으로 틀린 것은? (

[11. 접근 제한에 대한 설명으로 틀린 것은? (3)]
	default 접근 제한은 해당 클래스와 해당 패키지에서 사용을 허가함
	calss 접근 제한은 public, default 만 사용
	클래스 내부에서만 사용 허가하려면 private
